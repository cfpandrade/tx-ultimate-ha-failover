substitutions:
  # Device identification
  name: 'living_tx'
  friendly_name: "Living-TX"

  # Network configuration
  ha_ip: "192.168.50.168"           # Your Home Assistant IP
  ha_port: "8123"                    # Home Assistant port
  device_ip: "192.168.35.56"         # Fixed IP for this device
  ap_ssid: "Tx-Living"               # Fallback AP name

  # Monitoring intervals
  wifi_check_interval: "600s"        # WiFi watchdog check (10 min)
  ha_check_interval: "300s"          # HA availability check (5 min)
  nightlight_check_interval: "5"     # Minutes to check nightlight

  # Hardware configuration
  relay_count: "2"                   # Number of relays (1-3)
  vibra_time: 400ms                  # Vibration duration
  button_on_time: 500ms              # Button press duration

  # LED Colors - RGB format (0-100)
  button_brightness: "0"
  button_color: "{0,0,90}"           # Button active color (blue)

  nightlight: "on"
  nightlight_brightness: "0.2"
  nightlight_color: "{80,70,0}"      # Nightlight color (warm)

  touch_brightness: "1"
  touch_color: "{0,100,100}"         # Touch feedback (cyan)
  touch_effect: "Scan"

  long_press_brightness: "1"
  long_press_color: "{100,0,0}"      # Long press color (red)
  long_press_effect: ""

  multi_touch_brightness: "1"
  multi_touch_color: "{0,0,0}"       # Multi-touch color (off)
  multi_touch_effect: "Rainbow"

  swipe_left_brightness: "1"
  swipe_left_color: "{0,100,0}"      # Swipe left color (green)
  swipe_left_effect: ""

  swipe_right_brightness: "1"
  swipe_right_color: "{100,0,70}"    # Swipe right color (purple)
  swipe_right_effect: ""

  # Status indicator colors (hardcoded, but can be changed here)
  no_wifi_color_r: "1.0"             # Yellow when no WiFi
  no_wifi_color_g: "1.0"
  no_wifi_color_b: "0.0"

  ha_down_color_r: "1.0"             # Red when HA down
  ha_down_color_g: "0.0"
  ha_down_color_b: "0.0"

  ha_online_color_r: "0.0"           # Cyan when HA back online
  ha_online_color_g: "0.75"
  ha_online_color_b: "1.0"

  # Location for sunrise/sunset
  latitude: "40.7128°"
  longitude: "-74.0060°"

  relay_1_pin: GPIO18
  relay_2_pin: GPIO17
  relay_3_pin: GPIO27
  relay_4_pin: GPIO23

  vibra_motor_pin: GPIO21
  pa_power_pin: GPIO26

  led_pin: GPIO13
  status_led_pin: GPIO33

  uart_tx_pin: GPIO19
  uart_rx_pin: GPIO22

  audio_lrclk_pin: GPIO4
  audio_bclk_pin: GPIO2
  audio_sdata_pin: GPIO15

  touchpanel_power_pin: GPIO5

esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  project:
    name: smarthomeyourself.tx_ultimate
    version: "1.0"

  platformio_options:
    lib_deps:
      - ESP32Ping

  on_boot:
    priority: -100
    then:
      - binary_sensor.template.publish:
          id: touchfield_1
          state: OFF
      - binary_sensor.template.publish:
          id: touchfield_2
          state: OFF
      - binary_sensor.template.publish:
          id: touchfield_3
          state: OFF
      - binary_sensor.template.publish:
          id: multi_touch
          state: OFF
      - binary_sensor.template.publish:
          id: swipe_left
          state: OFF
      - binary_sensor.template.publish:
          id: swipe_right
          state: OFF
      - binary_sensor.template.publish:
          id: long_press
          state: OFF
      - script.execute: refresh_led_default
      - script.execute: refresh_nightlight

esp32:
  board: esp32dev
  framework:
    type: arduino

logger:
  level: DEBUG
  logs:
    binary_sensor: INFO
    light: INFO
    script: INFO
    switch: INFO
    tx_ultimate_touch: INFO
    uart_debug: INFO

api:
  encryption:
    key: !secret api_key

ota:
  - platform: esphome
    password: !secret ota_pass

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  use_address: ${device_ip}
  ap:
    ssid: ${ap_ssid}
    password: !secret ap_pass

improv_serial:

captive_portal:

# Bluetooth Proxy
esp32_ble_tracker:
  scan_parameters:
    interval: 1100ms
    window: 1100ms
    active: true

bluetooth_proxy:
  active: true

external_components:
  - source: /config/esphome/components
    components: [tx_ultimate_touch]
  - source:
      type: git
      url: https://github.com/trombik/esphome-component-ping
      ref: main
    components: [ ping ]

sensor:
  - platform: ping
    ip_address: ${ha_ip}
    update_interval: ${ha_check_interval}
    num_attempts: 5
    timeout: 1s
    loss:
      name: "${friendly_name} HA Packet Loss"
      id: ha_packet_loss
      internal: true  # Para que no aparezca en HA (solo uso interno)
    latency:
      name: "${friendly_name} HA Latency"
      id: ha_latency
      internal: true

globals:
  - id: nightlight_color
    type: int [3]
    restore_value: no
    initial_value: ${nightlight_color}
  - id: button_color
    type: int [3]
    restore_value: no
    initial_value: ${button_color}
  - id: long_press_color
    type: int [3]
    restore_value: no
    initial_value: ${long_press_color}
  - id: multi_touch_color
    type: int [3]
    restore_value: no
    initial_value: ${multi_touch_color}
  - id: swipe_left_color
    type: int [3]
    restore_value: no
    initial_value: ${swipe_left_color}
  - id: swipe_right_color
    type: int [3]
    restore_value: no
    initial_value: ${swipe_right_color}
  - id: touch_color
    type: int [3]
    restore_value: no
    initial_value: ${touch_color}

  # Dynamic toggles for local relay control
  - id: toggle_relay_1_on_touch
    type: bool
    restore_value: no
    initial_value: "false"
  - id: toggle_relay_2_on_touch
    type: bool
    restore_value: no
    initial_value: "false"
  - id: toggle_relay_3_on_touch
    type: bool
    restore_value: no
    initial_value: "false"
  
  # Estado de conectividad (0=normal, 1=sin_wifi, 2=ha_caido)
  - id: connectivity_status
    type: int
    restore_value: no
    initial_value: "0"

  # Flag para indicar que el sistema ya arrancó completamente
  - id: system_ready
    type: bool
    restore_value: no
    initial_value: "false"

binary_sensor:
  - platform: template
    name: "Touchfield 1"
    id: touchfield_1
    on_press:
      - if:
          condition:
            lambda: "return id(toggle_relay_1_on_touch);"
          then:
            - switch.toggle: relay_1
      - delay: ${button_on_time}
      - binary_sensor.template.publish:
          id: touchfield_1
          state: OFF
      - script.execute: refresh_led_default

  - platform: template
    name: "Touchfield 2"
    id: touchfield_2
    on_press:
      - if:
          condition:
            lambda: "return id(toggle_relay_2_on_touch);"
          then:
            - switch.toggle: relay_2
      - delay: ${button_on_time}
      - binary_sensor.template.publish:
          id: touchfield_2
          state: OFF
      - script.execute: refresh_led_default

  - platform: template
    name: "Touchfield 3"
    id: touchfield_3
    on_press:
      - if:
          condition:
            lambda: "return id(toggle_relay_3_on_touch);"
          then:
            - switch.toggle: relay_3
      - delay: ${button_on_time}
      - binary_sensor.template.publish:
          id: touchfield_3
          state: OFF
      - script.execute: refresh_led_default

  - platform: template
    name: "Swipe left"
    id: swipe_left
    on_press:
      - delay: ${button_on_time}
      - binary_sensor.template.publish:
          id: swipe_left
          state: OFF
      - script.execute: refresh_led_default

  - platform: template
    name: "Swipe_right"
    id: swipe_right
    on_press:
      - delay: ${button_on_time}
      - binary_sensor.template.publish:
          id: swipe_right
          state: OFF
      - script.execute: refresh_led_default

  - platform: template
    name: "Multi Touch"
    id: multi_touch
    on_press:
      - delay: ${button_on_time}
      - binary_sensor.template.publish:
          id: multi_touch
          state: OFF
      - script.execute: refresh_led_default

  - platform: template
    name: "Long Press"
    id: long_press
    on_press:
      - delay: ${button_on_time}
      - binary_sensor.template.publish:
          id: long_press
          state: OFF
      - script.execute: refresh_led_default

switch:
  - platform: gpio
    id: relay_1
    name: "${friendly_name} L1"
    pin: ${relay_1_pin}
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - script.execute: refresh_led_default
    on_turn_off:
      then:
        - script.execute: refresh_led_default

  - platform: gpio
    id: relay_2
    name: "${friendly_name} L2"
    pin: ${relay_2_pin}
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - script.execute: refresh_led_default
    on_turn_off:
      then:
        - script.execute: refresh_led_default

  - platform: gpio
    id: relay_3
    name: "${friendly_name} L3"
    pin: ${relay_3_pin}
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - script.execute: refresh_led_default
    on_turn_off:
      then:
        - script.execute: refresh_led_default

  - platform: gpio
    id: vibra
    pin: ${vibra_motor_pin}
    name: "${friendly_name} Vibration"
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - delay: ${vibra_time}
      - switch.turn_off: vibra

  - platform: gpio
    id: pa_power
    pin: ${pa_power_pin}
    name: "PA Power"
    internal: true
    restore_mode: ALWAYS_ON

  - platform: gpio
    name: "touch panel power"
    pin:
      number: ${touchpanel_power_pin}
      inverted: true
    id: touch_power
    internal: true
    restore_mode: RESTORE_DEFAULT_ON

  - platform: template
    name: "Nightlight"
    id: nightlight
    internal: true
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - script.execute: refresh_led_default
    on_turn_off:
      then:
        - script.execute: refresh_led_default

  - platform: template
    name: "Nightlight Active"
    id: nightlight_active
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - script.execute: refresh_led_default
    on_turn_off:
      then:
        - script.execute: refresh_led_default

  - platform: restart
    name: "${friendly_name} Restart"

light:
  - platform: neopixelbus
    type: GRB
    variant: WS2811
    pin: ${led_pin}
    num_leds: 28
    name: "NeoPixel Light"
    id: leds
    default_transition_length: 5s
    effects:
      - addressable_rainbow:
          name: "Rainbow"
          speed: 30
          width: 8
      - pulse:
          name: "Pulse"
          transition_length: 1.4s
          update_interval: 1s

    on_turn_off:
      then:
        - script.execute: refresh_led_default

  - platform: partition
    name: "LEDs Button right"
    id: leds_button_right
    internal: true
    segments:
      - id: leds
        from: 6
        to: 9
  - platform: partition
    name: "LEDs Button middle"
    id: leds_button_middle
    internal: true
    segments:
      - id: leds
        from: 8
        to: 10
  - platform: partition
    name: "LEDs Button left"
    id: leds_button_left
    internal: true
    segments:
      - id: leds
        from: 9
        to: 12

  - platform: partition
    name: "LEDs Nightlight"
    id: leds_nightlight
    internal: true
    segments:
      - id: leds
        from: 0
        to: 5
      - id: leds
        from: 8
        to: 8
      - id: leds
        from: 10
        to: 10
      - id: leds
        from: 13
        to: 19
      - id: leds
        from: 27
        to: 27
      - id: leds_top
        from: 0
        to: 6

  - platform: partition
    name: "LEDs Top"
    id: leds_top
    internal: true
    segments:
      - id: leds
        from: 20
        to: 26
    effects:
      - addressable_scan:
          name: "Scan"
      - addressable_rainbow:
          name: "Rainbow"
          speed: 10
          width: 20

media_player:
  - platform: i2s_audio
    id: media_out
    name: ${friendly_name} Player
    dac_type: external
    i2s_dout_pin: ${audio_sdata_pin}
    i2s_audio_id: audio_i2s
    i2s_comm_fmt: lsb    
    mode: mono

i2s_audio:
  id: audio_i2s
  i2s_lrclk_pin: ${audio_lrclk_pin}
  i2s_bclk_pin: ${audio_bclk_pin}

uart:
  tx_pin: ${uart_tx_pin}
  rx_pin: ${uart_rx_pin}
  id: my_uart
  baud_rate: 115200
  data_bits: 8
  stop_bits: 1
  parity: NONE
  debug:
    direction: RX
    dummy_receiver: false
    after:
      timeout: 2s
      bytes: 2048
    sequence:
      - lambda: UARTDebug::log_hex(direction, bytes, ' ');

tx_ultimate_touch:
  id: tx_touch
  uart: my_uart

  on_press:
    - script.execute: led_on_touch
    - lambda: >
        ESP_LOGD("tx_ultimate_touch.on_press", "Touch Position: %d / State: %d", touch.x, touch.state);

  on_release:
    - script.execute:
        id: handle_release
        pos: !lambda "return touch.x;"

    - switch.turn_on: vibra

    - lambda: >
        ESP_LOGD("tx_ultimate_touch.on_release", "Release Position: %d / State: %d", touch.x, touch.state);

  on_swipe_left:
    - script.execute: led_on_swipe_left

    - switch.turn_on: vibra

    - binary_sensor.template.publish:
        id: swipe_left
        state: ON

    - lambda: >
        ESP_LOGD("tx_ultimate_touch.on_swipe_left", "Swipe Left Position: %d / State: %d", touch.x, touch.state);

  on_swipe_right:
    - script.execute: led_on_swipe_right

    - switch.turn_on: vibra

    - binary_sensor.template.publish:
        id: swipe_right
        state: ON

    - lambda: >
        ESP_LOGD("tx_ultimate_touch.on_swipe_right", "Swipe Right Position: %d / State: %d", touch.x, touch.state);

  on_full_touch_release:
    - script.execute: led_on_full_touch

    - switch.turn_on: vibra

    - binary_sensor.template.publish:
        id: multi_touch
        state: ON

    - lambda: >
        ESP_LOGD("tx_ultimate_touch.on_full_touch_release", "Full Touch Release Position: %d / State: %d", touch.x, touch.state);

  on_long_touch_release:
    - script.execute: led_on_long_touch

    - switch.turn_on: vibra

    - binary_sensor.template.publish:
        id: long_press
        state: ON

    - lambda: >
        ESP_LOGD("tx_ultimate_touch.on_long_touch_release", "Long Touch Release Position: %d / State: %d", touch.x, touch.state);

time:
  - platform: homeassistant
  - platform: sntp
    on_time:
      # Configurable interval
      - seconds: 0
        minutes: /${nightlight_check_interval}
        then:
          - script.execute: refresh_nightlight

sun:
  latitude: ${latitude}
  longitude: ${longitude}

script:
  - id: refresh_nightlight
    mode: restart
    then:
      - if:
          condition:
            lambda: 'return "${nightlight}" == "on";'
          then:
            - if:
                condition:
                  - sun.is_below_horizon:
                then:
                  - switch.turn_on:
                      id: nightlight
                else:
                  - switch.turn_off:
                      id: nightlight

  - id: refresh_led_default
    mode: restart
    then:
      - light.turn_off: leds_top

      - if:
          condition:
            lambda: "return (${relay_count}>1 && id(relay_1).state) ;"
          then:
            - script.execute: led_on_button_left
          else:
            - script.execute: led_off_button_left

      - if:
          condition:
            lambda: "return (${relay_count}==3 && id(relay_2).state) || (${relay_count}==1 && id(relay_1).state);"
          then:
            - script.execute: led_on_button_middle
          else:
            - script.execute: led_off_button_middle

      - if:
          condition:
            lambda: "return (${relay_count}==2 && id(relay_2).state) || (${relay_count}==3 && id(relay_3).state);"
          then:
            - script.execute: led_on_button_right
          else:
            - script.execute: led_off_button_right

      - if:
          condition:
            lambda: "return id(nightlight).state || id(nightlight_active).state;"
          then:
            - script.execute: led_on_nightlight
          else:
            - light.turn_off: leds_nightlight

  - id: led_on_button_left
    mode: restart
    then:
      - light.turn_on:
          id: leds_button_left
          brightness: ${button_brightness}
          red: !lambda "return id(button_color)[0]/100.0;"
          green: !lambda "return id(button_color)[1]/100.0;"
          blue:  !lambda "return id(button_color)[2]/100.0;"

  - id: led_on_button_middle
    mode: restart
    then:
      - light.turn_on:
          id: leds_button_middle
          brightness: ${button_brightness}
          red: !lambda "return id(button_color)[0]/100.0;"
          green: !lambda "return id(button_color)[1]/100.0;"
          blue:  !lambda "return id(button_color)[2]/100.0;"

  - id: led_on_button_right
    mode: restart
    then:
      - light.turn_on:
          id: leds_button_right
          brightness: ${button_brightness}
          red: !lambda "return id(button_color)[0]/100.0;"
          green: !lambda "return id(button_color)[1]/100.0;"
          blue:  !lambda "return id(button_color)[2]/100.0;"

  - id: led_off_button_left
    mode: restart
    then:
      - if:
          condition:
            lambda: "return id(nightlight).state || id(nightlight_active).state;"
          then:
            - light.turn_on:
                id: leds_button_left
                brightness: ${nightlight_brightness}
                red: !lambda "return id(nightlight_color)[0]/100.0;"
                green: !lambda "return id(nightlight_color)[1]/100.0;"
                blue:  !lambda "return id(nightlight_color)[2]/100.0;"
          else:
            - light.turn_off:
                id: leds_button_left

  - id: led_off_button_middle
    mode: restart
    then:
      - if:
          condition:
            lambda: "return id(nightlight).state || id(nightlight_active).state;"
          then:
            - light.turn_on:
                id: leds_button_middle
                brightness: ${nightlight_brightness}
                red: !lambda "return id(nightlight_color)[0]/100.0;"
                green: !lambda "return id(nightlight_color)[1]/100.0;"
                blue:  !lambda "return id(nightlight_color)[2]/100.0;"
          else:
            - light.turn_off:
                id: leds_button_middle

  - id: led_off_button_right
    mode: restart
    then:
      - if:
          condition:
            lambda: "return id(nightlight).state || id(nightlight_active).state;"
          then:
            - light.turn_on:
                id: leds_button_right
                brightness: ${nightlight_brightness}
                red: !lambda "return id(nightlight_color)[0]/100.0;"
                green: !lambda "return id(nightlight_color)[1]/100.0;"
                blue:  !lambda "return id(nightlight_color)[2]/100.0;"
          else:
            - light.turn_off:
                id: leds_button_right

  - id: led_on_nightlight
    mode: restart
    then:
      - light.turn_on:
          id: leds_nightlight
          brightness: ${nightlight_brightness}
          red: !lambda "return id(nightlight_color)[0]/100.0;"
          green: !lambda "return id(nightlight_color)[1]/100.0;"
          blue:  !lambda "return id(nightlight_color)[2]/100.0;"

  - id: led_on_release
    mode: restart
    then:
      - light.turn_off:
          id: leds_top

  # Script modificado con indicadores de estado
  - id: led_on_touch
    mode: restart
    then:
      # Verifica el estado de conectividad y muestra indicador apropiado
      - if:
          condition:
            lambda: "return id(connectivity_status) == 1;"  # Sin WiFi
          then:
            # AMARILLO pulsante por 3 segundos
            - light.turn_on:
                id: leds_top
                brightness: 0.3
                red: ${no_wifi_color_r}
                green: ${no_wifi_color_g}
                blue: ${no_wifi_color_b}
                effect: "Pulse"
            - delay: 3s
            - light.turn_off: leds_top
            - script.execute: refresh_led_default
          else:
            - if:
                condition:
                  lambda: "return id(connectivity_status) == 2;"  # HA caído
                then:
                  # ROJO pulsante por 3 segundos
                  - light.turn_on:
                      id: leds_top
                      brightness: 0.3
                      red: ${ha_down_color_r}
                      green: ${ha_down_color_g}
                      blue: ${ha_down_color_b}
                      effect: "Pulse"
                  - delay: 3s
                  - light.turn_off: leds_top
                  - script.execute: refresh_led_default
                else:
                  # Comportamiento normal (HA online)
                  - light.turn_on:
                      id: leds_top
                      brightness: ${touch_brightness}
                      red: !lambda "return id(touch_color)[0]/100.0;"
                      green: !lambda "return id(touch_color)[1]/100.0;"
                      blue:  !lambda "return id(touch_color)[2]/100.0;"
                      effect: ${touch_effect}
                  - delay: 6s
                  - script.execute: refresh_led_default

  - id: led_on_swipe_left
    mode: restart
    then:
      - light.turn_on:
          id: leds_top
          brightness: ${swipe_left_brightness}
          red: !lambda "return id(swipe_left_color)[0]/100.0;"
          green: !lambda "return id(swipe_left_color)[1]/100.0;"
          blue:  !lambda "return id(swipe_left_color)[2]/100.0;"
          effect: ${swipe_left_effect}

  - id: led_on_swipe_right
    mode: restart
    then:
      - light.turn_on:
          id: leds_top
          brightness: ${swipe_right_brightness}
          red: !lambda "return id(swipe_right_color)[0]/100.0;"
          green: !lambda "return id(swipe_right_color)[1]/100.0;"
          blue:  !lambda "return id(swipe_right_color)[2]/100.0;"
          effect: ${swipe_right_effect}

  - id: led_on_full_touch
    mode: restart
    then:
      - light.turn_on:
          id: leds_top
          brightness: ${multi_touch_brightness}
          red: !lambda "return id(multi_touch_color)[0]/100.0;"
          green: !lambda "return id(multi_touch_color)[1]/100.0;"
          blue:  !lambda "return id(multi_touch_color)[2]/100.0;"
          effect: ${multi_touch_effect}

  - id: led_on_long_touch
    mode: restart
    then:
      - light.turn_on:
          id: leds_top
          brightness: ${long_press_brightness}
          red: !lambda "return id(long_press_color)[0]/100.0;"
          green: !lambda "return id(long_press_color)[1]/100.0;"
          blue:  !lambda "return id(long_press_color)[2]/100.0;"
          effect: ${long_press_effect}

  # Script para indicar que HA volvió online
  - id: ha_back_online_indicator
    mode: restart
    then:
      # AZURE (cyan/azul cielo) pulsante por 3 segundos
      - light.turn_on:
          id: leds_top
          brightness: 0.4
          red: ${ha_online_color_r}
          green: ${ha_online_color_g}
          blue: ${ha_online_color_b}
          effect: "Pulse"
      - delay: 3s
      - light.turn_off: leds_top
      - script.execute: refresh_led_default

  - id: handle_release
    mode: restart
    parameters:
      pos: int
    then:
      - if:
          condition:
            lambda: "return ${relay_count}==1;"
          then:
            - binary_sensor.template.publish:
                id: touchfield_1
                state: ON

      - if:
          condition:
            lambda: "return ${relay_count}==2;"
          then:
            - if:
                condition:
                  lambda: "return pos <= 5;"
                then:
                  - binary_sensor.template.publish:
                      id: touchfield_1
                      state: ON

                else:
                  - binary_sensor.template.publish:
                      id: touchfield_2
                      state: ON

      - if:
          condition:
            lambda: "return ${relay_count}==3;"
          then:
            - if:
                condition:
                  lambda: "return pos <= 3;"
                then:
                  - binary_sensor.template.publish:
                      id: touchfield_1
                      state: ON

                else:
                  - if:
                      condition:
                        lambda: "return pos <= 7;"
                      then:
                        - binary_sensor.template.publish:
                            id: touchfield_2
                            state: ON

                      else:
                        - binary_sensor.template.publish:
                            id: touchfield_3
                            state: ON

  - id: touch_led_marker
    mode: restart
    parameters:
      state: int
      pos: int
    then:
      - if:
          condition:
            lambda: "return state==1;"
          then:
            # RELEASE
            - light.turn_off: leds

          else:
            - if:
                condition:
                  lambda: "return state==2;"
                then:
                  # TOUCH
                  - light.turn_on:
                      id: leds
                      red: 1
                      green: 0
                      blue: 0
                  - delay: 6s
                  - light.turn_off: leds

                else:
                  - if:
                      condition:
                        lambda: "return state==11;"
                      then:
                        # FULL-TOUCH RELEASE
                        - light.turn_on:
                            id: leds
                            effect: "Rainbow"
                        - delay: 1s
                        - light.turn_off: leds

                      else:
                        # SWIPE
                        - if:
                            condition:
                              lambda: "return state==13;"
                            then:
                              # SWIPE LEFT
                              - light.turn_on:
                                  id: leds
                                  red: 0
                                  green: 1
                                  blue: 0

                        - if:
                            condition:
                              lambda: "return state==12;"
                            then:
                              # SWIPE RIGHT
                              - light.turn_on:
                                  id: leds
                                  red: 0
                                  green: 0
                                  blue: 1
                        - delay: 1s
                        - light.turn_off: leds

# ========================================
# WATCHDOG WiFi y Home Assistant (usando ping)
# ========================================
interval:
  # Marca el sistema como listo después de 2 minutos (permite tiempo para boot y conexión)
  - interval: 2min
    then:
      - lambda: |-
          static bool first_execution = true;
          if (first_execution) {
            first_execution = false;
            id(system_ready) = true;
            ESP_LOGI("system", "System ready. Watchdogs now active.");
          }

  # Reinicia si pierde WiFi (solo después de que el sistema esté listo)
  - interval: ${wifi_check_interval}
    then:
      - lambda: |-
          // Solo actúa si el sistema ya arrancó completamente
          if (!id(system_ready)) {
            return;
          }

          if (!WiFi.isConnected()) {
            ESP_LOGW("living_tx.wifi", "WiFi lost after successful boot. Restarting...");
            ESP.restart();
          }

  # Watchdog de Home Assistant usando sensor de ping
  - interval: 310s  # Ligeramente más que ha_check_interval para dar tiempo al ping
    then:
      - lambda: |-
          static bool ha_down = false;
          static int ha_down_count = 0;

          // Solo actúa si el sistema ya arrancó completamente
          if (!id(system_ready)) {
            return;
          }

          // Primero verifica si hay WiFi
          if (!WiFi.isConnected()) {
            if (!ha_down) {
              ha_down = true;
              ha_down_count = 0;
              ESP_LOGW("ha_watchdog", "No WiFi connection. Enabling local touch control.");
              id(toggle_relay_1_on_touch) = true;
              id(toggle_relay_2_on_touch) = true;
              id(toggle_relay_3_on_touch) = true;
              id(connectivity_status) = 1;  // Estado: Sin WiFi
            }
            return;
          }

          // Verifica si HA responde (usando packet loss del ping)
          // Si el ping no ha recibido respuesta, el sensor tendrá NaN o >80% loss
          if (isnan(id(ha_packet_loss).state) || id(ha_packet_loss).state > 80.0) {
            ha_down_count++;
            ESP_LOGW("ha_watchdog", "Home Assistant not reachable (attempt %d, loss: %.1f%%).",
                     ha_down_count, id(ha_packet_loss).state);

            // Solo activa control local después de 2 fallos consecutivos (10 minutos)
            if (ha_down_count >= 2 && !ha_down) {
              ha_down = true;
              ESP_LOGW("ha_watchdog", "Home Assistant down for 10+ minutes. Enabling local touch control.");
              id(toggle_relay_1_on_touch) = true;
              id(toggle_relay_2_on_touch) = true;
              id(toggle_relay_3_on_touch) = true;
              id(connectivity_status) = 2;  // Estado: HA caído
            }
          } else {
            // HA responde bien (packet loss < 80%)
            if (ha_down || ha_down_count > 0) {
              ha_down = false;
              ha_down_count = 0;
              ESP_LOGI("ha_watchdog", "Home Assistant back online (loss: %.1f%%, latency: %.1fms). Restoring normal touch behavior.",
                       id(ha_packet_loss).state, id(ha_latency).state);
              id(toggle_relay_1_on_touch) = false;
              id(toggle_relay_2_on_touch) = false;
              id(toggle_relay_3_on_touch) = false;
              id(connectivity_status) = 0;  // Estado: Normal

              // Ejecuta indicador visual de que HA volvió
              id(ha_back_online_indicator).execute();
            } else {
              // Reset counter si todo está bien
              ha_down_count = 0;
            }
          }