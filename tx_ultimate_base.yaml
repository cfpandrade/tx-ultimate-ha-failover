# TX Ultimate HA Failover - Base Configuration
# Version: 1.3.1
# This file contains all the core functionality
# Include this via packages in your device config

esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  project:
    name: smarthomeyourself.tx_ultimate
    version: "1.3.1"

  platformio_options:
    build_flags:
      - -Wno-deprecated-declarations  # Suppress I2S and ADC deprecation warnings

  on_boot:
    priority: -100
    then:
      - binary_sensor.template.publish:
          id: touchfield_1
          state: OFF
      - binary_sensor.template.publish:
          id: touchfield_2
          state: OFF
      - binary_sensor.template.publish:
          id: touchfield_3
          state: OFF
      - binary_sensor.template.publish:
          id: multi_touch
          state: OFF
      - binary_sensor.template.publish:
          id: swipe_left
          state: OFF
      - binary_sensor.template.publish:
          id: swipe_right
          state: OFF
      - binary_sensor.template.publish:
          id: long_press
          state: OFF
      - script.execute: refresh_led_default
      - script.execute: refresh_nightlight
      # Inicializar heartbeat HA
      - lambda: |-
          id(ha_last_seen) = millis();
      - delay: 5s
      - script.execute: check_ha_heartbeat

esp32:
  board: esp32dev
  framework:
    type: arduino

logger:
  level: INFO
  logs:
    binary_sensor: WARN
    light: WARN
    script: WARN
    switch: WARN
    tx_ultimate_touch: WARN
    component: ERROR

improv_serial:

captive_portal:

external_components:
  - source:
      type: git
      url: https://github.com/SmartHome-yourself/sonoff-tx-ultimate-for-esphome
      ref: main
    components: [tx_ultimate_touch]

# HTTP request para verificar HA
http_request:
  timeout: 5s
  verify_ssl: false

globals:
  - id: nightlight_color
    type: int [3]
    restore_value: no
    initial_value: ${nightlight_color}
  - id: button_color
    type: int [3]
    restore_value: no
    initial_value: ${button_color}
  - id: long_press_color
    type: int [3]
    restore_value: no
    initial_value: ${long_press_color}
  - id: multi_touch_color
    type: int [3]
    restore_value: no
    initial_value: ${multi_touch_color}
  - id: swipe_left_color
    type: int [3]
    restore_value: no
    initial_value: ${swipe_left_color}
  - id: swipe_right_color
    type: int [3]
    restore_value: no
    initial_value: ${swipe_right_color}
  - id: touch_color
    type: int [3]
    restore_value: no
    initial_value: ${touch_color}
  - id: ha_failover_nightlight_color
    type: int [3]
    restore_value: no
    initial_value: ${ha_failover_nightlight_color}

  # Variables para heartbeat HA y estado de relays
  - id: ha_last_seen
    type: unsigned long
    restore_value: no
    initial_value: '0'
  - id: ha_offline_mode
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: ha_failed_checks
    type: int
    restore_value: no
    initial_value: '0'
  - id: ha_max_failures_before_failover
    type: int
    restore_value: no
    initial_value: '10'  # 10 failures × 60s = 10 minutos
  - id: relay_1_saved_state
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: relay_2_saved_state
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: relay_3_saved_state
    type: bool
    restore_value: no
    initial_value: 'false'

  # Control dinámico de toggle manual
  - id: toggle_relay_1_on_touch
    type: bool
    restore_value: no
    initial_value: 'false'  # Normalmente controlado por HA
  - id: toggle_relay_2_on_touch
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: toggle_relay_3_on_touch
    type: bool
    restore_value: no
    initial_value: 'false'

  # Configuración failover
  - id: ha_failover_turn_on_lights
    type: bool
    restore_value: no
    initial_value: ${ha_failover_turn_on_lights}

binary_sensor:
  # Estado de conexión HA
  - platform: template
    name: "${friendly_name} HA Online"
    id: ha_online
    device_class: connectivity

  - platform: template
    name: "Touchfield 1"
    id: touchfield_1
    on_press:
      - if:
          condition:
            lambda: "return id(toggle_relay_1_on_touch);"
          then:
            - switch.toggle: relay_1
      - delay: ${button_on_time}
      - binary_sensor.template.publish:
          id: touchfield_1
          state: OFF
      - script.execute: refresh_led_default

  - platform: template
    name: "Touchfield 2"
    id: touchfield_2
    on_press:
      - if:
          condition:
            lambda: "return id(toggle_relay_2_on_touch);"
          then:
            - switch.toggle: relay_2
      - delay: ${button_on_time}
      - binary_sensor.template.publish:
          id: touchfield_2
          state: OFF
      - script.execute: refresh_led_default

  - platform: template
    name: "Touchfield 3"
    id: touchfield_3
    on_press:
      - if:
          condition:
            lambda: "return id(toggle_relay_3_on_touch);"
          then:
            - switch.toggle: relay_3
      - delay: ${button_on_time}
      - binary_sensor.template.publish:
          id: touchfield_3
          state: OFF
      - script.execute: refresh_led_default

  - platform: template
    name: "Swipe left"
    id: swipe_left
    on_press:
      - delay: ${button_on_time}
      - binary_sensor.template.publish:
          id: swipe_left
          state: OFF
      - script.execute: refresh_led_default

  - platform: template
    name: "Swipe_right"
    id: swipe_right
    on_press:
      - delay: ${button_on_time}
      - binary_sensor.template.publish:
          id: swipe_right
          state: OFF
      - script.execute: refresh_led_default

  - platform: template
    name: "Multi Touch"
    id: multi_touch
    on_press:
      - delay: ${button_on_time}
      - binary_sensor.template.publish:
          id: multi_touch
          state: OFF
      - script.execute: refresh_led_default

  - platform: template
    name: "Long Press"
    id: long_press
    on_press:
      - delay: ${button_on_time}
      - binary_sensor.template.publish:
          id: long_press
          state: OFF
      - script.execute: refresh_led_default

switch:
  - platform: gpio
    id: relay_1
    name: "${friendly_name} L1"
    pin: GPIO18  # TX Ultimate hardware pin
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - script.execute: refresh_led_default
    on_turn_off:
      then:
        - script.execute: refresh_led_default

  - platform: gpio
    id: relay_2
    name: "${friendly_name} L2"
    pin: GPIO17  # TX Ultimate hardware pin
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - script.execute: refresh_led_default
    on_turn_off:
      then:
        - script.execute: refresh_led_default

  - platform: gpio
    id: relay_3
    name: "${friendly_name} L3"
    pin: GPIO27  # TX Ultimate hardware pin
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - script.execute: refresh_led_default
    on_turn_off:
      then:
        - script.execute: refresh_led_default

  - platform: gpio
    id: vibra
    pin: GPIO21  # TX Ultimate hardware pin
    name: "${friendly_name} Vibration"
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - delay: ${vibra_time}
      - switch.turn_off: vibra

  - platform: gpio
    id: pa_power
    pin: GPIO26  # TX Ultimate hardware pin
    name: "PA Power"
    internal: true
    restore_mode: ALWAYS_ON

  - platform: gpio
    name: "touch panel power"
    pin:
      number: GPIO5  # TX Ultimate hardware pin
      inverted: true
    id: touch_power
    internal: true
    restore_mode: RESTORE_DEFAULT_ON

  - platform: template
    name: "Nightlight Auto"
    id: nightlight
    internal: true
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - script.execute: refresh_led_default
    on_turn_off:
      then:
        - script.execute: refresh_led_default

  - platform: template
    name: "${friendly_name} Nightlight"
    id: nightlight_active
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - script.execute: refresh_led_default
    on_turn_off:
      then:
        - script.execute: refresh_led_default

  - platform: restart
    name: "${friendly_name} Restart"

light:
  - platform: neopixelbus
    type: GRB
    variant: WS2811
    pin: GPIO13  # TX Ultimate hardware pin
    num_leds: 28
    name: "NeoPixel Light"
    id: leds
    default_transition_length: 5s
    effects:
      - addressable_rainbow:
          name: "Rainbow"
          speed: 30
          width: 8
      - pulse:
          name: "Pulse"
          transition_length: 1.4s
          update_interval: 1s
    on_turn_off:
      then:
        - script.execute: refresh_led_default

  - platform: partition
    name: "LEDs Button right"
    id: leds_button_right
    internal: true
    segments:
      - id: leds
        from: 6
        to: 9
  - platform: partition
    name: "LEDs Button middle"
    id: leds_button_middle
    internal: true
    segments:
      - id: leds
        from: 8
        to: 10
  - platform: partition
    name: "LEDs Button left"
    id: leds_button_left
    internal: true
    segments:
      - id: leds
        from: 9
        to: 12

  - platform: partition
    name: "LEDs Nightlight"
    id: leds_nightlight
    internal: true
    segments:
      - id: leds
        from: 0
        to: 5
      - id: leds
        from: 8
        to: 8
      - id: leds
        from: 10
        to: 10
      - id: leds
        from: 13
        to: 19
      - id: leds
        from: 27
        to: 27
      - id: leds_top
        from: 0
        to: 6

  - platform: partition
    name: "LEDs Top"
    id: leds_top
    internal: true
    segments:
      - id: leds
        from: 20
        to: 26
    effects:
      - addressable_scan:
          name: "Scan"
      - addressable_rainbow:
          name: "Rainbow"
          speed: 10
          width: 20

media_player:
  - platform: i2s_audio
    id: media_out
    name: ${friendly_name} Player
    dac_type: external
    i2s_dout_pin: GPIO15  # TX Ultimate hardware pin
    i2s_audio_id: audio_i2s
    i2s_comm_fmt: lsb
    mode: mono

i2s_audio:
  id: audio_i2s
  i2s_lrclk_pin: GPIO4   # TX Ultimate hardware pin
  i2s_bclk_pin: GPIO2    # TX Ultimate hardware pin

uart:
  tx_pin: GPIO19  # TX Ultimate hardware pin
  rx_pin: GPIO22  # TX Ultimate hardware pin
  id: my_uart
  baud_rate: 115200
  data_bits: 8
  stop_bits: 1
  parity: NONE

tx_ultimate_touch:
  id: tx_touch
  uart: my_uart

  on_press:
    - script.execute: led_on_touch
    - lambda: >
        ESP_LOGD("tx_ultimate_touch.on_press", "Touch Position: %d / State: %d", touch.x, touch.state);

  on_release:
    - script.execute:
        id: handle_release
        pos: !lambda "return touch.x;"

    - switch.turn_on: vibra

    - lambda: >
        ESP_LOGD("tx_ultimate_touch.on_release", "Release Position: %d / State: %d", touch.x, touch.state);

  on_swipe_left:
    - script.execute: led_on_swipe_left

    - switch.turn_on: vibra

    - binary_sensor.template.publish:
        id: swipe_left
        state: ON

    - lambda: >
        ESP_LOGD("tx_ultimate_touch.on_swipe_left", "Swipe Left Position: %d / State: %d", touch.x, touch.state);

  on_swipe_right:
    - script.execute: led_on_swipe_right

    - switch.turn_on: vibra

    - binary_sensor.template.publish:
        id: swipe_right
        state: ON

    - lambda: >
        ESP_LOGD("tx_ultimate_touch.on_swipe_right", "Swipe Right Position: %d / State: %d", touch.x, touch.state);

  on_full_touch_release:
    - script.execute: led_on_full_touch

    - switch.turn_on: vibra

    - binary_sensor.template.publish:
        id: multi_touch
        state: ON

    - lambda: >
        ESP_LOGD("tx_ultimate_touch.on_full_touch_release", "Full Touch Release Position: %d / State: %d", touch.x, touch.state);

  on_long_touch_release:
    - script.execute: led_on_long_touch

    - switch.turn_on: vibra

    - binary_sensor.template.publish:
        id: long_press
        state: ON

    - lambda: >
        ESP_LOGD("tx_ultimate_touch.on_long_touch_release", "Long Touch Release Position: %d / State: %d", touch.x, touch.state);

time:
  - platform: homeassistant
  - platform: sntp
    on_time:
      # Every 5 minutes
      - seconds: 0
        minutes: /5
        then:
          - script.execute: refresh_nightlight

sun:
  latitude: ${latitude}
  longitude: ${longitude}

script:
  - id: refresh_nightlight
    mode: restart
    then:
      - if:
          condition:
            lambda: 'return "${nightlight}" == "on";'
          then:
            - if:
                condition:
                  - sun.is_below_horizon:
                then:
                  - switch.turn_on:
                      id: nightlight
                else:
                  - switch.turn_off:
                      id: nightlight

  - id: refresh_led_default
    mode: restart
    then:
      - light.turn_off: leds_top

      - if:
          condition:
            lambda: "return (${relay_count}>1 && id(relay_1).state) ;"
          then:
            - script.execute: led_on_button_left
          else:
            - script.execute: led_off_button_left

      - if:
          condition:
            lambda: "return (${relay_count}==3 && id(relay_2).state) || (${relay_count}==1 && id(relay_1).state);"
          then:
            - script.execute: led_on_button_middle
          else:
            - script.execute: led_off_button_middle

      - if:
          condition:
            lambda: "return (${relay_count}==2 && id(relay_2).state) || (${relay_count}==3 && id(relay_3).state);"
          then:
            - script.execute: led_on_button_right
          else:
            - script.execute: led_off_button_right

      - if:
          condition:
            lambda: "return id(nightlight).state || id(nightlight_active).state;"
          then:
            - script.execute: led_on_nightlight
          else:
            - light.turn_off: leds_nightlight

  - id: led_on_button_left
    mode: restart
    then:
      - light.turn_on:
          id: leds_button_left
          brightness: ${button_brightness}
          red: !lambda "return id(button_color)[0]/100.0;"
          green: !lambda "return id(button_color)[1]/100.0;"
          blue:  !lambda "return id(button_color)[2]/100.0;"

  - id: led_on_button_middle
    mode: restart
    then:
      - light.turn_on:
          id: leds_button_middle
          brightness: ${button_brightness}
          red: !lambda "return id(button_color)[0]/100.0;"
          green: !lambda "return id(button_color)[1]/100.0;"
          blue:  !lambda "return id(button_color)[2]/100.0;"

  - id: led_on_button_right
    mode: restart
    then:
      - light.turn_on:
          id: leds_button_right
          brightness: ${button_brightness}
          red: !lambda "return id(button_color)[0]/100.0;"
          green: !lambda "return id(button_color)[1]/100.0;"
          blue:  !lambda "return id(button_color)[2]/100.0;"

  - id: led_off_button_left
    mode: restart
    then:
      - if:
          condition:
            lambda: "return id(nightlight).state || id(nightlight_active).state;"
          then:
            - light.turn_on:
                id: leds_button_left
                brightness: ${nightlight_brightness}
                red: !lambda "return id(nightlight_color)[0]/100.0;"
                green: !lambda "return id(nightlight_color)[1]/100.0;"
                blue:  !lambda "return id(nightlight_color)[2]/100.0;"
          else:
            - light.turn_off:
                id: leds_button_left

  - id: led_off_button_middle
    mode: restart
    then:
      - if:
          condition:
            lambda: "return id(nightlight).state || id(nightlight_active).state;"
          then:
            - light.turn_on:
                id: leds_button_middle
                brightness: ${nightlight_brightness}
                red: !lambda "return id(nightlight_color)[0]/100.0;"
                green: !lambda "return id(nightlight_color)[1]/100.0;"
                blue:  !lambda "return id(nightlight_color)[2]/100.0;"
          else:
            - light.turn_off:
                id: leds_button_middle

  - id: led_off_button_right
    mode: restart
    then:
      - if:
          condition:
            lambda: "return id(nightlight).state || id(nightlight_active).state;"
          then:
            - light.turn_on:
                id: leds_button_right
                brightness: ${nightlight_brightness}
                red: !lambda "return id(nightlight_color)[0]/100.0;"
                green: !lambda "return id(nightlight_color)[1]/100.0;"
                blue:  !lambda "return id(nightlight_color)[2]/100.0;"
          else:
            - light.turn_off:
                id: leds_button_right

  - id: led_on_nightlight
    mode: restart
    then:
      - light.turn_on:
          id: leds_nightlight
          brightness: ${nightlight_brightness}
          red: !lambda "return id(nightlight_color)[0]/100.0;"
          green: !lambda "return id(nightlight_color)[1]/100.0;"
          blue:  !lambda "return id(nightlight_color)[2]/100.0;"

  - id: led_on_release
    mode: restart
    then:
      - light.turn_off:
          id: leds_top

  - id: led_on_touch
    mode: restart
    then:
      - light.turn_on:
          id: leds_top
          brightness: ${touch_brightness}
          red: !lambda "return id(touch_color)[0]/100.0;"
          green: !lambda "return id(touch_color)[1]/100.0;"
          blue:  !lambda "return id(touch_color)[2]/100.0;"
          effect: ${touch_effect}
      - delay: 6s
      - script.execute: refresh_led_default

  - id: led_on_swipe_left
    mode: restart
    then:
      - light.turn_on:
          id: leds_top
          brightness: ${swipe_left_brightness}
          red: !lambda "return id(swipe_left_color)[0]/100.0;"
          green: !lambda "return id(swipe_left_color)[1]/100.0;"
          blue:  !lambda "return id(swipe_left_color)[2]/100.0;"
          effect: ${swipe_left_effect}

  - id: led_on_swipe_right
    mode: restart
    then:
      - light.turn_on:
          id: leds_top
          brightness: ${swipe_right_brightness}
          red: !lambda "return id(swipe_right_color)[0]/100.0;"
          green: !lambda "return id(swipe_right_color)[1]/100.0;"
          blue:  !lambda "return id(swipe_right_color)[2]/100.0;"
          effect: ${swipe_right_effect}

  - id: led_on_full_touch
    mode: restart
    then:
      - light.turn_on:
          id: leds_top
          brightness: ${multi_touch_brightness}
          red: !lambda "return id(multi_touch_color)[0]/100.0;"
          green: !lambda "return id(multi_touch_color)[1]/100.0;"
          blue:  !lambda "return id(multi_touch_color)[2]/100.0;"
          effect: ${multi_touch_effect}

  - id: led_on_long_touch
    mode: restart
    then:
      - light.turn_on:
          id: leds_top
          brightness: ${long_press_brightness}
          red: !lambda "return id(long_press_color)[0]/100.0;"
          green: !lambda "return id(long_press_color)[1]/100.0;"
          blue:  !lambda "return id(long_press_color)[2]/100.0;"
          effect: ${long_press_effect}

  - id: handle_release
    mode: restart
    parameters:
      pos: int
    then:
      - if:
          condition:
            lambda: "return ${relay_count}==1;"
          then:
            - binary_sensor.template.publish:
                id: touchfield_1
                state: ON

      - if:
          condition:
            lambda: "return ${relay_count}==2;"
          then:
            - if:
                condition:
                  lambda: "return pos <= 5;"
                then:
                  - binary_sensor.template.publish:
                      id: touchfield_1
                      state: ON

                else:
                  - binary_sensor.template.publish:
                      id: touchfield_2
                      state: ON

      - if:
          condition:
            lambda: "return ${relay_count}==3;"
          then:
            - if:
                condition:
                  lambda: "return pos <= 3;"
                then:
                  - binary_sensor.template.publish:
                      id: touchfield_1
                      state: ON

                else:
                  - if:
                      condition:
                        lambda: "return pos <= 7;"
                      then:
                        - binary_sensor.template.publish:
                            id: touchfield_2
                            state: ON

                      else:
                        - binary_sensor.template.publish:
                            id: touchfield_3
                            state: ON

  # Script para verificar heartbeat con HA usando HTTP API
  - id: check_ha_heartbeat
    mode: single
    then:
      - http_request.get:
          url: "${ha_url}/api/"
          request_headers:
            Authorization: !lambda 'return "${ha_api_token}";'
          on_response:
            then:
              - lambda: |-
                  ESP_LOGI("heartbeat", "HA API respondió correctamente");

                  // Actualizar timestamp y resetear contador de fallos
                  id(ha_last_seen) = millis();
                  id(ha_failed_checks) = 0;

                  // Si estábamos en modo offline, restaurar estados
                  if (id(ha_offline_mode)) {
                    ESP_LOGI("heartbeat", "HA volvió online! Restaurando comportamiento automático");
                    id(ha_offline_mode) = false;

                    // DESACTIVAR MODO MANUAL (volver a control por HA)
                    ESP_LOGI("heartbeat", "Desactivando modo manual, volviendo a control HA");
                    id(toggle_relay_1_on_touch) = false;
                    id(toggle_relay_2_on_touch) = false;
                    id(toggle_relay_3_on_touch) = false;

                    // Restaurar estados guardados de relays
                    if (id(relay_1).state != id(relay_1_saved_state)) {
                      ESP_LOGI("heartbeat", "Restaurando Relay 1 a: %s", id(relay_1_saved_state) ? "ON" : "OFF");
                      id(relay_1_saved_state) ? id(relay_1).turn_on() : id(relay_1).turn_off();
                    }
                    if (id(relay_2).state != id(relay_2_saved_state)) {
                      ESP_LOGI("heartbeat", "Restaurando Relay 2 a: %s", id(relay_2_saved_state) ? "ON" : "OFF");
                      id(relay_2_saved_state) ? id(relay_2).turn_on() : id(relay_2).turn_off();
                    }
                    if (id(relay_3).state != id(relay_3_saved_state)) {
                      ESP_LOGI("heartbeat", "Restaurando Relay 3 a: %s", id(relay_3_saved_state) ? "ON" : "OFF");
                      id(relay_3_saved_state) ? id(relay_3).turn_on() : id(relay_3).turn_off();
                    }

                    id(ha_online).publish_state(true);
                  }

              # Restaurar nightlight a color normal
              - script.execute: refresh_led_default
          on_error:
            - lambda: |-
                id(ha_failed_checks)++;
                ESP_LOGW("heartbeat", "Error al conectar con HA API (fallo #%d/10)", id(ha_failed_checks));

                // Verificar si necesitamos entrar en modo failover
                if (id(ha_failed_checks) >= 10 && !id(ha_offline_mode)) {
                  ESP_LOGE("heartbeat", "HA offline por >10 minutos, activando MODO MANUAL");
                  id(ha_offline_mode) = true;

                  // Guardar estados actuales
                  id(relay_1_saved_state) = id(relay_1).state;
                  id(relay_2_saved_state) = id(relay_2).state;
                  id(relay_3_saved_state) = id(relay_3).state;

                  ESP_LOGI("heartbeat", "Estados guardados - R1:%s R2:%s R3:%s",
                          id(relay_1_saved_state) ? "ON" : "OFF",
                          id(relay_2_saved_state) ? "ON" : "OFF",
                          id(relay_3_saved_state) ? "ON" : "OFF");

                  // ACTIVAR MODO MANUAL (los switches funcionan como interruptores)
                  ESP_LOGW("heartbeat", "Activando modo MANUAL en los switches");
                  id(toggle_relay_1_on_touch) = true;
                  id(toggle_relay_2_on_touch) = true;
                  id(toggle_relay_3_on_touch) = true;

                  // Opcional: encender luces solo en living/comedor
                  if (id(ha_failover_turn_on_lights)) {
                    ESP_LOGW("heartbeat", "Encendiendo todas las luces por seguridad");
                    id(relay_1).turn_on();
                    id(relay_2).turn_on();
                    id(relay_3).turn_on();
                  }

                  id(ha_online).publish_state(false);
                }

            # Cambiar nightlight a color de alerta si HA está offline
            - if:
                condition:
                  lambda: "return id(ha_offline_mode);"
                then:
                  - light.turn_on:
                      id: leds_nightlight
                      brightness: ${nightlight_brightness}
                      red: !lambda "return id(ha_failover_nightlight_color)[0]/100.0;"
                      green: !lambda "return id(ha_failover_nightlight_color)[1]/100.0;"
                      blue: !lambda "return id(ha_failover_nightlight_color)[2]/100.0;"

  - id: touch_led_marker
    mode: restart
    parameters:
      state: int
      pos: int
    then:
      - if:
          condition:
            lambda: "return state==1;"
          then:
            # RELEASE
            - light.turn_off: leds

          else:
            - if:
                condition:
                  lambda: "return state==2;"
                then:
                  # TOUCH
                  - light.turn_on:
                      id: leds
                      red: 1
                      green: 0
                      blue: 0
                  - delay: 6s
                  - light.turn_off: leds

                else:
                  - if:
                      condition:
                        lambda: "return state==11;"
                      then:
                        # FULL-TOUCH RELEASE
                        - light.turn_on:
                            id: leds
                            effect: "Rainbow"
                        - delay: 1s
                        - light.turn_off: leds

                      else:
                        # SWIPE
                        - if:
                            condition:
                              lambda: "return state==13;"
                            then:
                              # SWIPE LEFT
                              - light.turn_on:
                                  id: leds
                                  red: 0
                                  green: 1
                                  blue: 0

                        - if:
                            condition:
                              lambda: "return state==12;"
                            then:
                              # SWIPE RIGHT
                              - light.turn_on:
                                  id: leds
                                  red: 0
                                  green: 0
                                  blue: 1
                        - delay: 1s
                        - light.turn_off: leds

interval:
  # Verificar conexión WiFi cada 10 minutos
  - interval: 10min
    then:
      - if:
          condition:
            lambda: "return millis() > 180000 && !network::is_connected();"
          then:
            - logger.log:
                level: WARN
                tag: "wifi"
                format: "WiFi desconectado por >3 minutos, reiniciando..."
            - lambda: "ESP.restart();"

  # Heartbeat con Home Assistant
  - interval: ${ha_heartbeat_interval}
    then:
      - script.execute: check_ha_heartbeat
